package def.compiler;

import def.compiler.JackTokenizer.KeyWord;
import def.compiler.JackTokenizer.TokenType;
import def.compiler.SymbolTable.Kind;
import def.compiler.VMWriter.Command;
import def.compiler.VMWriter.Segment;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

/**
 * Created by dflor on 7/19/2017.
 * <p>
 * {@link CompilationEngine}: Effects the actual compilation output.  Gets its input from a
 * {@link JackTokenizer} and emits its parsed structure into an output file/stream. The
 * output is generated by a series of the {@code compilexxx()} routines, one for every syntactic
 * element xxx of the Jack grammar.  The contract between these routines is that each
 * {@code compilexxx()} routine should read the syntactic construct xxx from the input,
 * {@link JackTokenizer#advance()} the tokenizer exactly beyond xxx, and output the parsing of xxx.  Thus,
 * {@code compilexxx()} may only be called if indeed xxx is the next syntactic element of the input.
 * In the first version of the compiler, this module emits a structured printout of the code,
 * wrapped in XML tags.  In the final version of the compiler, this module generates executable
 * VM code.  In both cases, the parsing logic and API are exactly the same.
 *
 * V2
 * This class does the compilation itself.  It reads its input from a Jack Tokenizer and
 * writes its output into a VMWriter.  It is organized as a series of compilexxx() routines,
 * where xxx is a syntactic element of the Jack language.  The contract between
 * these routines is that each compilexxx() routine should read the syntactic construct
 * xxx from the input, advance() the tokenizer exactly beyond xxx, and emit to the
 * output VM code effecting the semantics of xxx.  Thus compilexxx() may only be
 * called if indeed xxx is the next syntactic element of the input.  If xxx is a part of an
 * expression and thus has a value, the emitted code should compute this value and
 * leave it at the top of the VM stack.
 */
public class CompilationEngine {

    public static boolean outputXML = true;
    public static boolean extendedXML = false;
    private JackTokenizer inputTokenizer;
    private PrintWriter outputWriter;
    private VMWriter vmWriter;
    private String indentLevel;
    private SymbolTable symbolTable;

    private String className;
    private int labelCount;
    private boolean subroutineIsMethodCall;

    /**
     * Creates a new compilation engine with the given input and output.
     * The next routine called must be {@link #compileClass()}.
     *
     * @param inputTokenizer A Jack Tokenizer constructed on the input file to translate.
     *                       The constructor will do the first call to {@link JackTokenizer#advance()}
     * @param outputFile     The file to output the compiled VM/xml code.
     */
    public CompilationEngine(JackTokenizer inputTokenizer, File outputFile) throws FileNotFoundException {
        this.inputTokenizer = inputTokenizer;
        outputWriter = new PrintWriter(outputFile);
        vmWriter = new VMWriter(outputFile);

        JackTokenizer.NO_COMMENTS = true;

        if (inputTokenizer.hasMoreTokens()) {
            inputTokenizer.advance();
        } else {
            throw new CompilationException("No tokens in this file!");
        }

        indentLevel = "";
        symbolTable = new SymbolTable();
        labelCount = 0;
        subroutineIsMethodCall = false;
    }

    private void advanceTokenizer() {
        if (inputTokenizer.hasMoreTokens()) {
            inputTokenizer.advance();
        } else {
            throw new CompilationException("End of file reached while compiling!");
        }
    }

    private void increaseIndent() {
        indentLevel += "  ";
    }

    private void decreaseIndent() {
        if (indentLevel.length() >= 2)
            indentLevel = indentLevel.substring(0, indentLevel.length() - 2);
    }

    private void println(String preIndentLine) {
        outputWriter.println(indentLevel + preIndentLine);
    }

    private void printIdentifier(String identifier) {
        printIdentifier(identifier, "", false, -1, "");
    }

    private void printIdentifier(String identifier, String category, boolean isBeingDefined) {
        printIdentifier(identifier, category, isBeingDefined, -1, "");
    }

    private void printIdentifier(String identifier, String category, boolean isBeingDefined, int index, String type) {
        if (extendedXML) {
            println("<identifier category=\"" + category + "\" > ");
            increaseIndent();
            println(identifier);
            println(isBeingDefined?"<definition />":"<usage />");
            if (index != -1) {
                println("<index> " + index + " </index>");
            }
            if (type != null && !type.equals("")) {
                println("<type> " + type + " </type>");
            }
            decreaseIndent();
            println("</identifier>");
        } else {
            println("<identifier> " + identifier + " </identifier>");
        }
    }

    private Segment kindToSegment(Kind kind) {
        Segment segment = null;
        switch (kind) {
            case STATIC:
                segment = Segment.STATIC;
                break;
            case FIELD:
                segment = Segment.THIS;
                break;
            case ARG:
                segment = Segment.ARGUMENT;
                break;
            case VAR:
                segment = Segment.LOCAL;
                break;
            default:
                throw new CompilationException("The given variable does not exist!");
        }
        return segment;
    }

    /**
     * Compiles a complete class.
     */
    public void compileClass() {
        //class
        //  'class' className '{' classVarDec* subroutineDec* '}'

        if (inputTokenizer.tokenType() != TokenType.KEYWORD && inputTokenizer.keyWord() != KeyWord.CLASS)
            throw new CompilationException("first token is not a the keyword \'class\'!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
            throw new CompilationException("the class name is not an identifier");

        className = inputTokenizer.identifier();

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL && inputTokenizer.symbol() != '{')
            throw new CompilationException("Missing \'{\' in class declaration");

        if (outputXML) {
            println("<class>");
            increaseIndent();
            println("<keyword> class </keyword>");
            printIdentifier(className, "class", true);
            println("<symbol> { </symbol>");
        }

        boolean isClassVarDec;

        advanceTokenizer();

        isClassVarDec = inputTokenizer.tokenType() == TokenType.KEYWORD &&
                (inputTokenizer.keyWord() == KeyWord.STATIC || inputTokenizer.keyWord() == KeyWord.FIELD);

        while (isClassVarDec) {
            // the next construct is a classVarDec
            compileClassVariableDeclaration();

            // the tokenizer is now advanced past the last classVarDec
            isClassVarDec = inputTokenizer.tokenType() == TokenType.KEYWORD &&
                    (inputTokenizer.keyWord() == KeyWord.STATIC || inputTokenizer.keyWord() == KeyWord.FIELD);

        }


        boolean isSubroutineDec;

        isSubroutineDec = inputTokenizer.tokenType() == TokenType.KEYWORD && (inputTokenizer.keyWord() == KeyWord.CONSTRUCTOR
                || inputTokenizer.keyWord() == KeyWord.METHOD || inputTokenizer.keyWord() == KeyWord.FUNCTION);

        while (isSubroutineDec) {
            compileSubroutine();
            isSubroutineDec = inputTokenizer.tokenType() == TokenType.KEYWORD && (inputTokenizer.keyWord() == KeyWord.CONSTRUCTOR
                    || inputTokenizer.keyWord() == KeyWord.METHOD || inputTokenizer.keyWord() == KeyWord.FUNCTION);
        }

        // compile methods have advanced past all the methods and variable declarations, now we are at the end of the class
        if (inputTokenizer.tokenType() != TokenType.SYMBOL && inputTokenizer.symbol() != '}')
            throw new CompilationException("Missing \'}\' in class declaration");

        if (outputXML) {
            println("<symbol> } </symbol>");
            decreaseIndent();
            println("</class>");
        }
    }

    /**
     * Compiles a static declaration or a field declaration
     */
    public void compileClassVariableDeclaration() {
        //classVarDec
        //  ('static'|'field') ('int'|'char'|'boolean'| className) varName (',' varName)* ';'

        // we know that the next thing is a keyword, either static or field, so we skip that check
        boolean isStatic = inputTokenizer.keyWord() == KeyWord.STATIC;

        advanceTokenizer();

        boolean typeIsPrimitive = inputTokenizer.tokenType() != TokenType.IDENTIFIER;
        KeyWord primitiveType = null;
        String identifierType = null;

        if (typeIsPrimitive) {
            primitiveType = inputTokenizer.keyWord();

            if (inputTokenizer.tokenType() != TokenType.KEYWORD || (primitiveType != KeyWord.INT && primitiveType != KeyWord.CHAR && primitiveType != KeyWord.BOOLEAN))
                throw new CompilationException("Variable type is not an class name or a primitive data type!");
        } else {
            identifierType = inputTokenizer.identifier();
        }

        advanceTokenizer();


        List<String> varNames = new ArrayList<>();

        boolean hasMoreVarNames = true;

        while (hasMoreVarNames) {
            if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
                throw new CompilationException("Expected an identifier for the variable name");

            varNames.add(inputTokenizer.identifier());

            symbolTable.define(inputTokenizer.identifier(), typeIsPrimitive?primitiveType.toString().toLowerCase():identifierType,
                    isStatic? Kind.STATIC: Kind.FIELD);

            advanceTokenizer();

            if (inputTokenizer.tokenType() != TokenType.SYMBOL || (inputTokenizer.symbol() != ',' && inputTokenizer.symbol() != ';'))
                throw new CompilationException("Expected either \',\' or \';\'");

            hasMoreVarNames = inputTokenizer.symbol() == ',';

            advanceTokenizer();
        }

        if (outputXML) {
            println("<classVarDec>");
            increaseIndent();
            println("<keyword> " + (isStatic ? "static" : "field") + " </keyword>");
            if (typeIsPrimitive) {
                println("<keyword> " + primitiveType.toString().toLowerCase() + " </keyword>");
            } else {
                printIdentifier(identifierType, "class", false);
            }

            for (int i = 0; i < varNames.size(); i++) {
                printIdentifier(varNames.get(i), isStatic?"static":"field", true,
                        symbolTable.indexOf(varNames.get(i)), symbolTable.typeOf(varNames.get(i)));
                println("<symbol> " + (i + 1 == varNames.size() ? ";" : ",") + " </symbol>");
            }

            decreaseIndent();
            println("</classVarDec>");
        }
    }

    /**
     * Compiles a complete method, function, or constructor.
     */
    public void compileSubroutine() {
        //subroutineDec
        //  ('constructor'|'function'|'method') ('void'|'int'|'char'|'boolean'| className) subroutineName '('
        //      parameterList ')'
        //subroutineBody
        //  '{' varDec* statements '}'

        symbolTable.startSubroutine();

        // we know the token is a valid keyword, the compileClass() makes sure of this
        KeyWord subroutineType = inputTokenizer.keyWord();

        subroutineIsMethodCall = subroutineType == KeyWord.METHOD;

        if (subroutineType == KeyWord.METHOD) {
            symbolTable.define("this", className, Kind.ARG);
        }

        advanceTokenizer();

        boolean returnTypeIsPrimitive = inputTokenizer.tokenType() != TokenType.IDENTIFIER;
        KeyWord primitiveType = null;
        String identifierType = null;

        if (returnTypeIsPrimitive) {
            primitiveType = inputTokenizer.keyWord();

            if (inputTokenizer.tokenType() != TokenType.KEYWORD || (primitiveType != KeyWord.INT && primitiveType != KeyWord.CHAR
                    && primitiveType != KeyWord.BOOLEAN && primitiveType != KeyWord.VOID))
                throw new CompilationException("Return type is not an class name, a primitive data type, or void!");
        } else {
            identifierType = inputTokenizer.identifier();
        }

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
            throw new CompilationException("Expected subroutine name identifier!");

        String subroutineName = inputTokenizer.identifier();

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '(')
            throw new CompilationException("Expected \'(\' after subroutine name!");

        advanceTokenizer();

        if (outputXML) {
            println("<subroutineDec>");
            increaseIndent();
            println("<keyword> " + subroutineType.toString().toLowerCase() + " </keyword>");

            if (returnTypeIsPrimitive) {
                println("<keyword> " + primitiveType.toString().toLowerCase() + " </keyword>");
            } else {
                printIdentifier(identifierType, "class", false);
            }

            printIdentifier(subroutineName, "subroutine", true);
            println("<symbol> ( </symbol>");
        }

        compileParameterList();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ')')
            throw new CompilationException("Expected \')\' after parameter list");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '{')
            throw new CompilationException("Expected \'{\' to begin subroutine body!");


        if (outputXML) {
            println("<symbol> ) </symbol>");
            println("<subroutineBody>");
            increaseIndent();
            println("<symbol> { </symbol>");
        }

        advanceTokenizer();

        boolean hasMoreVarDecs = inputTokenizer.tokenType() == TokenType.KEYWORD && inputTokenizer.keyWord() == KeyWord.VAR;

        while (hasMoreVarDecs) {
            compileVariableDeclaration();
            hasMoreVarDecs = inputTokenizer.tokenType() == TokenType.KEYWORD && inputTokenizer.keyWord() == KeyWord.VAR;
        }

        if (!outputXML) {
            vmWriter.writeFunction(className + "." + subroutineName, symbolTable.varCount(Kind.VAR));

            // set the this pointer for methods
            if (subroutineType == KeyWord.METHOD) {
                vmWriter.writePush(Segment.ARGUMENT, 0);
                vmWriter.writePop(Segment.POINTER, 0);
            }

            // allocate a space in the heap, and point the this pointer at it.
            if (subroutineType == KeyWord.CONSTRUCTOR) {
                vmWriter.writePush(Segment.CONSTANT, symbolTable.varCount(Kind.FIELD));
                vmWriter.writeCall("Memory.alloc", 1);
                vmWriter.writePop(Segment.POINTER, 0);
            }
        }

        compileStatements();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '}')
            throw new CompilationException("Expected \'}\' after statements, to close subroutine body");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> } </symbol>");
            decreaseIndent();
            println("</subroutineBody>");
            decreaseIndent();
            println("</subroutineDec>");
        }
    }

    /**
     * Compiles a (possibly empty) parameter list, not including the enclosing "()".
     */
    public void compileParameterList() {
        //parameterList
        //  ( (('int'|'char'|'boolean'| className) varName) (',' ('int'|'char'|'boolean'| className) varName)*)?

        boolean hasMoreParams;

        hasMoreParams = inputTokenizer.tokenType() != TokenType.SYMBOL;

        List<Boolean> typeIsPrimitive = new ArrayList<>();
        List<KeyWord> primitiveType = new ArrayList<>();
        List<String> identifierType = new ArrayList<>();
        List<String> variableName = new ArrayList<>();

        int i = 0;

        while (hasMoreParams) {
            KeyWord primitiveVarType = inputTokenizer.keyWord();
            if (inputTokenizer.tokenType() != TokenType.IDENTIFIER && (inputTokenizer.tokenType() != TokenType.KEYWORD ||
                    (primitiveVarType != KeyWord.INT && primitiveVarType != KeyWord.CHAR && primitiveVarType != KeyWord.BOOLEAN)))
                throw new CompilationException("Expected primitive type or class name in parameter list!");

            typeIsPrimitive.add(inputTokenizer.tokenType() == TokenType.KEYWORD);
            primitiveType.add(primitiveVarType);
            identifierType.add(inputTokenizer.identifier());

            advanceTokenizer();

            if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
                throw new CompilationException("Expected an identifier for the parameter variable name!");

            variableName.add(inputTokenizer.identifier());

            advanceTokenizer();

            if (inputTokenizer.tokenType() != TokenType.SYMBOL)
                throw new CompilationException("Expected symbol after parameter variable declaration!");

            hasMoreParams = inputTokenizer.symbol() == ',';

            if (hasMoreParams) {
                advanceTokenizer();
            }

            symbolTable.define(variableName.get(i), typeIsPrimitive.get(i)?
                    primitiveType.get(i).toString().toLowerCase():identifierType.get(i), Kind.ARG);

            i++;
        }

        if (outputXML) {
            println("<parameterList>");
            increaseIndent();
            for (i = 0; i < variableName.size(); i++) {
                if (typeIsPrimitive.get(i)) {
                    println("<keyword> " + primitiveType.get(i).toString().toLowerCase() + " </keyword>");
                } else {
                    printIdentifier(identifierType.get(i), "class", false);
                }

                printIdentifier(variableName.get(i), "arg", true,
                        symbolTable.indexOf(variableName.get(i)), symbolTable.typeOf(variableName.get(i)));

                if (i < variableName.size() - 1) {
                    println("<symbol> , </symbol>");
                }
            }
            decreaseIndent();
            println("</parameterList>");
        }
    }

    /**
     * Compiles a var declaration.
     */
    public void compileVariableDeclaration() {
        //varDec
        //  'var' ('int'|'char'|'boolean'| className) varName (',' varName)* ';'

        if (inputTokenizer.tokenType() != TokenType.KEYWORD || inputTokenizer.keyWord() != KeyWord.VAR)
            throw new CompilationException("Expected keyword \'var\' in variable declaration!");

        advanceTokenizer();

        KeyWord primitiveType = inputTokenizer.keyWord();
        String identifierType = inputTokenizer.identifier();

        if (inputTokenizer.tokenType() != TokenType.IDENTIFIER && (inputTokenizer.tokenType() != TokenType.KEYWORD ||
                (primitiveType != KeyWord.INT && primitiveType != KeyWord.CHAR && primitiveType != KeyWord.BOOLEAN)))
            throw new CompilationException("Expected primitive type or class name as variable type!");

        boolean typeIsPrimitive = inputTokenizer.tokenType() == TokenType.KEYWORD;

        List<String> variableNames = new ArrayList<>();

        boolean hasMoreVariableNames = true;

        while (hasMoreVariableNames) {
            advanceTokenizer();

            if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
                throw new CompilationException("Expected identifier for variable name!");

            variableNames.add(inputTokenizer.identifier());

            symbolTable.define(inputTokenizer.identifier(), typeIsPrimitive?primitiveType.toString().toLowerCase():identifierType, Kind.VAR);

            advanceTokenizer();

            if (inputTokenizer.tokenType() != TokenType.SYMBOL || (inputTokenizer.symbol() != ',' && inputTokenizer.symbol() != ';'))
                throw new CompilationException("Expected symbol \',\' or \';\' after variable name");

            hasMoreVariableNames = inputTokenizer.symbol() == ',';
        }

        // advance the tokenizer past the terminating ;
        advanceTokenizer();

        if (outputXML) {
            println("<varDec>");
            increaseIndent();
            println("<keyword> var </keyword>");

            if (typeIsPrimitive) {
                println("<keyword> " + primitiveType.toString().toLowerCase() + " </keyword>");
            } else {
                printIdentifier(identifierType, "class", false);
            }

            // we know there is at least one variable declared
            printIdentifier(variableNames.get(0), "var", true,
                    symbolTable.indexOf(variableNames.get(0)), symbolTable.typeOf(variableNames.get(0)));

            for (int i = 1; i < variableNames.size(); i++) {
                println("<symbol> , </symbol>");
                printIdentifier(variableNames.get(i), "var", true, symbolTable.indexOf(variableNames.get(i)), symbolTable.typeOf(variableNames.get(i)));
            }

            println("<symbol> ; </symbol>");
            decreaseIndent();
            println("</varDec>");
        }
    }

    /**
     * Compiles a sequence of statements, not including the enclosing "{}".
     */
    public void compileStatements() {
        //statements
        //  statement*
        //statement
        //  letStatement|ifStatement|whileStatement|doStatement|returnStatement

        if (outputXML) {
            println("<statements>");
            increaseIndent();
        }

        boolean hasMoreStatements;

        KeyWord statementKeyword = inputTokenizer.keyWord();
        hasMoreStatements = inputTokenizer.tokenType() == TokenType.KEYWORD && (statementKeyword == KeyWord.LET ||
                statementKeyword == KeyWord.IF || statementKeyword == KeyWord.WHILE || statementKeyword == KeyWord.DO ||
                statementKeyword == KeyWord.RETURN);

        while (hasMoreStatements) {
            switch (statementKeyword) {
                case LET:
                    compileLet();
                    break;
                case DO:
                    compileDo();
                    break;
                case IF:
                    compileIf();
                    break;
                case WHILE:
                    compileWhile();
                    break;
                case RETURN:
                    compileReturn();
                    break;
            }

            statementKeyword = inputTokenizer.keyWord();
            hasMoreStatements = inputTokenizer.tokenType() == TokenType.KEYWORD && (statementKeyword == KeyWord.LET ||
                    statementKeyword == KeyWord.IF || statementKeyword == KeyWord.WHILE || statementKeyword == KeyWord.DO ||
                    statementKeyword == KeyWord.RETURN);
        }

        if (outputXML) {
            decreaseIndent();
            println("</statements>");
        }
    }

    /**
     * Compiles a do statement.
     */
    public void compileDo() {
        //doStatement
        //  'do' subroutineCall ';'

        if (inputTokenizer.tokenType() != TokenType.KEYWORD || inputTokenizer.keyWord() != KeyWord.DO)
            throw new CompilationException("Expected keyword \'do\' in do statement!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
            throw new CompilationException("Expected an identifier for the subroutine name!");

        if (outputXML) {
            println("<doStatement>");
            increaseIndent();
            println("<keyword> do </keyword>");
        }

        String subroutineString = inputTokenizer.identifier();

        advanceTokenizer();

        compileSubroutineCall(subroutineString);

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ';')
            throw new CompilationException("Expected symbol \';\' terminating do statement");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> ; </symbol>");
            decreaseIndent();
            println("</doStatement>");
        } else {
            // discard the return value
            vmWriter.writePop(Segment.TEMP, 0);
        }

    }

    /**
     * Compiles a let statement.
     */
    public void compileLet() {
        //letStatement
        //  'let' varName ('[' expression ']')? '=' expression ';'

        if (inputTokenizer.tokenType() != TokenType.KEYWORD || inputTokenizer.keyWord() != KeyWord.LET)
            throw new CompilationException("Expected keyword \'let\' for a let statement!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
            throw new CompilationException("Expected an identifier for a let statement!");

        String variableName = inputTokenizer.identifier();

        boolean arrayExpression;

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || (inputTokenizer.symbol() != '[' && inputTokenizer.symbol() != '='))
            throw new CompilationException("Expected either symbol \'[\' or \'=\'");

        arrayExpression = inputTokenizer.symbol() == '[';

        if (arrayExpression) {
            advanceTokenizer();
        }

        if (outputXML) {
            println("<letStatement>");
            increaseIndent();
            println("<keyword> let </keyword>");
            printIdentifier(variableName, symbolTable.kindOf(variableName).toString().toLowerCase(), false,
                    symbolTable.indexOf(variableName), symbolTable.typeOf(variableName));

            if (arrayExpression) {
                println("<symbol> [ </symbol>");
            }
        }

        if (arrayExpression) {
            compileExpression();

            if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ']')
                throw new CompilationException("Expected symbol \']\' after array index expression!");

            advanceTokenizer();
        }

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '=')
            throw new CompilationException("Expected symbol \'=\' after variable in let statement!");

        advanceTokenizer();

        if (outputXML) {
            if (arrayExpression) {
                println("<symbol> ] </symbol>");
            }

            println("<symbol> = </symbol>");
        }

        compileExpression();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ';')
            throw new CompilationException("Expected symbol \';\' terminating let statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> ; </symbol>");
            decreaseIndent();
            println("</letStatement>");
        } else {
            // at the top of the stack is the value of the expression to the right of the '=' sign.
            // underneath that is the array index, if using arrays.

            if (arrayExpression) {
                vmWriter.writePop(Segment.TEMP, 1);
                vmWriter.writePush(kindToSegment(symbolTable.kindOf(variableName)), symbolTable.indexOf(variableName));
                vmWriter.writeArithmetic(Command.ADD);
                vmWriter.writePop(Segment.POINTER, 1);
                vmWriter.writePush(Segment.TEMP, 1);
                vmWriter.writePop(Segment.THAT, 0);
            } else {
                vmWriter.writePop(kindToSegment(symbolTable.kindOf(variableName)), symbolTable.indexOf(variableName));
            }
        }
    }

    /**
     * Compiles a while statement.
     */
    public void compileWhile() {
        //whileStatement
        //  'while' '(' expression ')' '{' statements '}'
        int labelCount = this.labelCount;
        this.labelCount++;

        if (inputTokenizer.tokenType() != TokenType.KEYWORD || inputTokenizer.keyWord() != KeyWord.WHILE)
            throw new CompilationException("Expected keyword \'while\' in while statement!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '(')
            throw new CompilationException("Expected symbol \'(\' in while statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<whileStatement>");
            increaseIndent();
            println("<keyword> while </keyword>");
            println("<symbol> ( </symbol>");
        } else {
            // insert the loop label
            vmWriter.writeLabel("whileStart"+labelCount);
        }

        compileExpression();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ')')
            throw new CompilationException("Expected symbol \')\' in while statement!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '{')
            throw new CompilationException("Expected symbol \'{\' in while statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> ) </symbol>");
            println("<symbol> { </symbol>");
        } else {
            // the top of the stack is the boolean condition for the loop
            vmWriter.writeArithmetic(Command.NOT);
            vmWriter.writeIf("whileEnd"+labelCount);
        }

        compileStatements();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '}')
            throw new CompilationException("Expected symbol \'}\' in while statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> } </symbol>");
            decreaseIndent();
            println("</whileStatement>");
        } else {
            //end of loop, return to beginning
            vmWriter.writeGoto("whileStart"+labelCount);
            vmWriter.writeLabel("whileEnd"+labelCount);
        }
    }

    /**
     * Compiles an if statement, possibly with a trailing else clause.
     */
    public void compileIf() {
        //ifStatement
        //  'if '(' expression ')' '{' statements '}' ('else' '{'statements'}')?
        int labelCount = this.labelCount;
        this.labelCount++;

        if (inputTokenizer.tokenType() != TokenType.KEYWORD || inputTokenizer.keyWord() != KeyWord.IF)
            throw new CompilationException("Expected keyword \'if\' in if statement!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '(')
            throw new CompilationException("Expected symbol \'(\' in while statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<ifStatement>");
            increaseIndent();
            println("<keyword> if </keyword>");
            println("<symbol> ( </symbol>");
        }

        compileExpression();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ')')
            throw new CompilationException("Expected symbol \')\' in if statement!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '{')
            throw new CompilationException("Expected symbol \'{\' in if statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> ) </symbol>");
            println("<symbol> { </symbol>");
        } else {
            // top of the stack is the boolean condition for the if statement
            vmWriter.writeArithmetic(Command.NOT);
            vmWriter.writeIf("ifEnd"+labelCount);
        }

        compileStatements();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '}')
            throw new CompilationException("Expected symbol \'}\' in if statement!");

        advanceTokenizer();

        if (inputTokenizer.tokenType() == TokenType.KEYWORD && inputTokenizer.keyWord() == KeyWord.ELSE) {
            advanceTokenizer();

            if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '{')
                throw new CompilationException("Expected symbol \'{\' in if statement!");

            advanceTokenizer();

            if (outputXML) {
                println("<symbol> } </symbol>");
                println("<keyword> else </keyword>");
                println("<symbol> { </symbol>");
            } else {
                vmWriter.writeGoto("elseEnd"+labelCount);
                vmWriter.writeLabel("ifEnd"+labelCount);
            }

            compileStatements();

            if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '}')
                throw new CompilationException("Expected symbol \'}\' in if statement!");

            advanceTokenizer();

            if (!outputXML) {
                vmWriter.writeLabel("elseEnd"+labelCount);
            }
        } else {
            if (!outputXML) {
                vmWriter.writeLabel("ifEnd"+labelCount);
            }
        }

        if (outputXML) {
            println("<symbol> } </symbol>");
            decreaseIndent();
            println("</ifStatement>");
        }
    }

    /**
     * Compiles a return statement.
     */
    public void compileReturn() {
        //returnStatement
        //  'return' expression? ';'

        if (inputTokenizer.tokenType() != TokenType.KEYWORD || inputTokenizer.keyWord() != KeyWord.RETURN)
            throw new CompilationException("Expected keyword \'return\' in return statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<returnStatement>");
            increaseIndent();
            println("<keyword> return </keyword>");
        }

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ';') {
            compileExpression();
        } else {
            if (!outputXML) {
                vmWriter.writePush(Segment.CONSTANT, 0);
            }
        }

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ';')
            throw new CompilationException("Expected symbol \';\' after return statement!");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> ; </symbol>");
            decreaseIndent();
            println("</returnStatement>");
        } else {
            vmWriter.writeReturn();
        }
    }

    /**
     * Compiles an expression.
     */
    public void compileExpression() {
        //expression
        //  term (('+'|'-'|'*'|'/'|'&'|'|'|'<'|'>'|'=') term)*

        if (outputXML) {
            println("<expression>");
            increaseIndent();
        }

        compileTerm();

        boolean hasMoreTerms = inputTokenizer.tokenType() == TokenType.SYMBOL && "+-*/&|<>=".indexOf(inputTokenizer.symbol()) != -1;

        while (hasMoreTerms) {
            char operator = inputTokenizer.symbol();

            if (outputXML) {
                switch (operator) {
                    case '<':
                        println("<symbol> &lt; </symbol>");
                        break;
                    case '>':
                        println("<symbol> &gt; </symbol>");
                        break;
                    case '&':
                        println("<symbol> &amp; </symbol>");
                        break;
                    default:
                        println("<symbol> " + operator + " </symbol>");
                        break;
                }
            }

            advanceTokenizer();

            compileTerm();

            if (!outputXML) {
                switch (operator) {
                    case '*':
                        vmWriter.writeCall("Math.multiply", 2);
                        break;
                    case '/':
                        vmWriter.writeCall("Math.divide", 2);
                        break;
                    default:
                        vmWriter.writeArithmetic(Command.getBinaryCommandFromSymbol(operator));
                        break;
                }
            }

            hasMoreTerms = inputTokenizer.tokenType() == TokenType.SYMBOL && "+-*/&|<>=".indexOf(inputTokenizer.symbol()) != -1;
        }


        if (outputXML) {
            decreaseIndent();
            println("</expression>");
        }
    }

    /**
     * Compiles a term.
     * This routine is faced with a slight difficulty when trying to decide between some of the alternative parsing rules.
     * Specifically, if the current token is an identifier, the routine must distinguish between a variable, an array entry, and a subroutine call.
     * A single lookahead token, which may be one of "[", "(", or "." suffices to distinguish between the three possibilities.
     * Any other token is not part of this term and should not be advanced over.
     */
    public void compileTerm() {
        //term
        //  integerConstant|stringConstant|('true'|'false'|'null'|'this')|varName|varName'['expression']'|subroutineCall
        //  |'('expression')'|('-'|'~') term

        if (outputXML) {
            println("<term>");
            increaseIndent();
        }

        switch (inputTokenizer.tokenType()) {

            case KEYWORD:
                KeyWord keyword = inputTokenizer.keyWord();
                if (keyword != KeyWord.TRUE && keyword != KeyWord.FALSE && keyword != KeyWord.NULL && keyword != KeyWord.THIS)
                    throw new CompilationException("Expected one of the keywords \'true\', \'false\', \'null\', or \'this\' in keyword constant");

                if (outputXML) {
                    println("<keyword> " + keyword.toString().toLowerCase() + " </keyword>");
                } else {
                    switch (keyword) {
                        case TRUE:
                            vmWriter.writePush(Segment.CONSTANT, 1);
                            vmWriter.writeArithmetic(Command.NEG);
                            break;
                        case FALSE:
                        case NULL:
                            vmWriter.writePush(Segment.CONSTANT, 0);
                            break;
                        case THIS:
                            vmWriter.writePush(Segment.POINTER, 0);
                            break;
                    }
                }

                advanceTokenizer();

                break;
            case SYMBOL:
                char symbol = inputTokenizer.symbol();
                if (symbol == '(') {
                    advanceTokenizer();

                    if (outputXML) {
                        println("<symbol> ( </symbol>");
                    }

                    compileExpression();

                    if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ')')
                        throw new CompilationException("Expected a closing parenthesis after expression in parenthetical term!");

                    if (outputXML) {
                        println("<symbol> ) </symbol>");
                    }

                    advanceTokenizer();
                } else if (symbol == '-' || symbol == '~') {
                    advanceTokenizer();
                    if (outputXML) {
                        println("<symbol> " + symbol + " </symbol>");
                    }

                    compileTerm();

                    if (!outputXML) {
                        vmWriter.writeArithmetic(Command.getUnaryCommandFromSymbol(symbol));
                    }

                } else
                    throw new CompilationException("Expected one of symbols \'-\', \'~\', or \'(\' in term!");
                break;
            case IDENTIFIER:
                String identifier = inputTokenizer.identifier();

                advanceTokenizer();

                boolean isSubroutine = false;
                boolean isArray = false;

                if (inputTokenizer.tokenType() == TokenType.SYMBOL && (inputTokenizer.symbol() == '(' || inputTokenizer.symbol() == '.')) {
                    compileSubroutineCall(identifier);
                    isSubroutine = true;
                } else if (inputTokenizer.tokenType() == TokenType.SYMBOL && inputTokenizer.symbol() == '[') {
                    isArray = true;
                    advanceTokenizer();
                }

                if (!isSubroutine) {
                    if (outputXML) {
                        printIdentifier(identifier, symbolTable.kindOf(identifier).toString().toLowerCase(),
                                false, symbolTable.indexOf(identifier), symbolTable.typeOf(identifier));

                        if (isArray) {
                            println("<symbol> [ </symbol>");
                        }
                    } else {
                        vmWriter.writePush(kindToSegment(symbolTable.kindOf(identifier)), symbolTable.indexOf(identifier));
                    }

                    if (isArray) {
                        compileExpression();

                        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ']')
                            throw new CompilationException("Expected symbol \']\' after array index expression!");

                        if (outputXML) {
                            println("<symbol> ] </symbol>");
                        } else {
                            // the array base and the index are both the stack, we add them and then get the value at that address
                            vmWriter.writeArithmetic(Command.ADD);
                            vmWriter.writePop(Segment.POINTER, 1);
                            vmWriter.writePush(Segment.THAT, 0);
                        }

                        advanceTokenizer();
                    }
                }


                break;
            case INT_CONSTANT:
                if (inputTokenizer.intVal() > 32767)
                    throw new CompilationException("The integer constant \'" + inputTokenizer.intVal() + "\' is to large!");

                if (outputXML) {
                    println("<integerConstant> " + inputTokenizer.intVal() + " </integerConstant>");
                } else {
                    vmWriter.writePush(Segment.CONSTANT, inputTokenizer.intVal());
                }

                advanceTokenizer();
                break;
            case STRING_CONSTANT:
                if (outputXML) {
                    println("<stringConstant> " + inputTokenizer.stringVal() + " </stringConstant>");
                } else {
                    //create the string, now it is on top of the stack
                    String string = inputTokenizer.stringVal();
                    vmWriter.writePush(Segment.CONSTANT, string.length());
                    vmWriter.writeCall("String.new", 1);
                    //add each char to the string, using the appendChar method, the string is at the top stack after each iteration
                    for (int i = 0; i < string.length(); i++) {
                        vmWriter.writePush(Segment.CONSTANT, string.charAt(i));
                        vmWriter.writeCall("String.appendChar", 2);
                    }
                }
                advanceTokenizer();
                break;
        }


        if (outputXML) {
            decreaseIndent();
            println("</term>");
        }
    }

    /**
     * Compiles a (possibly empty) comma-separated list of expressions.
     * @return The number of expressions in the expression list.
     */
    public int compileExpressionList() {
        //expressionList
        //  (expression (',' expression)* )?

        boolean hasNext = inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ')';
        int numExpressions = 0;

        if (outputXML) {
            println("<expressionList>");
            increaseIndent();
        }

        while (hasNext) {
            compileExpression();
            numExpressions++;

            if (inputTokenizer.tokenType() != TokenType.SYMBOL || (inputTokenizer.symbol() != ')' && inputTokenizer.symbol() != ','))
                throw new CompilationException("Expected symbol \',\' or \')\' after an expression in an expression list!");

            hasNext = inputTokenizer.symbol() == ',';

            if (hasNext) {
                if (outputXML) {
                    println("<symbol> , </symbol>");
                }

                advanceTokenizer();
            }
        }

        if (outputXML) {
            decreaseIndent();
            println("</expressionList>");
        }

        return numExpressions;
    }

    private void compileSubroutineCall(String firstIdentifier) {
        //subroutineCall
        //  subroutineName '(' expressionList ')' | (className|varName) '.' subroutineName '(' expressionList ')'

        String classOrVarName, subroutineName;

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || (inputTokenizer.symbol() != '(' && inputTokenizer.symbol() != '.'))
            throw new CompilationException("Expected symbol \'(\' or \'.\' after identifier in subroutine call!");

        boolean hasClassOrVarName = inputTokenizer.symbol() == '.';
        boolean isMethodCall;
        boolean isVariableThis = false;

        advanceTokenizer();

        if (hasClassOrVarName) {
            classOrVarName = firstIdentifier;

            // it is a method if the symbol exists, making it a variable.
            isMethodCall = symbolTable.kindOf(classOrVarName) != Kind.NONE;

            if (inputTokenizer.tokenType() != TokenType.IDENTIFIER)
                throw new CompilationException("Expected an identifier after symbol \'.\' in subroutine call");

            subroutineName = inputTokenizer.identifier();

            advanceTokenizer();

            if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != '(')
                throw new CompilationException("Expected symbol \'(\' after subroutine name in subroutine call!");

            advanceTokenizer();
        } else {
            classOrVarName = className;
            subroutineName = firstIdentifier;
            isMethodCall = true;
            isVariableThis = true;
        }

        if (outputXML) {
            if (hasClassOrVarName) {
                Kind kind = symbolTable.kindOf(classOrVarName);
                printIdentifier(classOrVarName, kind!= Kind.NONE?kind.toString().toLowerCase():"class",
                        false, symbolTable.indexOf(classOrVarName), symbolTable.typeOf(classOrVarName));
                println("<symbol> . </symbol>");
            }

            printIdentifier(subroutineName, "subroutine", false);
            println("<symbol> ( </symbol>");
        } else {
            if (isMethodCall) {
                if (isVariableThis) {
                    vmWriter.writePush(Segment.POINTER, 0);
                } else {
                    vmWriter.writePush(kindToSegment(symbolTable.kindOf(classOrVarName)), symbolTable.indexOf(classOrVarName));
                }
            }
        }

        int numArgs = compileExpressionList();

        if (inputTokenizer.tokenType() != TokenType.SYMBOL || inputTokenizer.symbol() != ')')
            throw new CompilationException("Expected symbol \')\' after expression list in subroutine call!");

        advanceTokenizer();

        if (outputXML) {
            println("<symbol> ) </symbol>");
        } else {
            // if it is a method call, we also pushed the variable and the class is the type of the variable.
            if (isMethodCall) {
                numArgs++;

                //if the variable is implicitly this, then we already set it.
                if (!isVariableThis) {
                    classOrVarName = symbolTable.typeOf(classOrVarName);
                }
            }

            vmWriter.writeCall(classOrVarName+"."+subroutineName, numArgs);
        }
    }

    public void close() {
        outputWriter.flush();
        outputWriter.close();
        vmWriter.close();
        inputTokenizer.close();
    }

    public class CompilationException extends RuntimeException {
        public CompilationException(String message) {
            super(message);
        }

        public void closeCompilationEngine() {
            close();
        }
    }
}
